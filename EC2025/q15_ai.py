# AI generated by ChatGPT using GPT-5.1, using my original q15.py script as a basis

from ec import *
# optimized, corrected solver (drop-in replacement)
import heapq
from bisect import bisect_left, bisect_right
from functools import lru_cache


# --- Spatial index builder ---
def build_index(v_segs, h_segs):
    """
    Build:
      v_index: x -> (starts_list, ends_list) for intervals of y at that x
      h_index: y -> (starts_list, ends_list) for intervals of x at that y
    and sorted coordinate lists v_xs, h_ys.
    """
    v_raw = {}
    h_raw = {}

    for (a, b) in v_segs:
        # vertical: same x
        x = a[0]
        y1, y2 = a[1], b[1]
        if y1 > y2:
            y1, y2 = y2, y1
        v_raw.setdefault(x, []).append((y1, y2))

    for (a, b) in h_segs:
        # horizontal: same y
        y = a[1]
        x1, x2 = a[0], b[0]
        if x1 > x2:
            x1, x2 = x2, x1
        h_raw.setdefault(y, []).append((x1, x2))

    def prepare(d):
        out = {}
        for k, intervals in d.items():
            intervals.sort()
            starts = [s for s, e in intervals]
            ends = [e for s, e in intervals]
            out[k] = (starts, ends)
        return out

    v_index = prepare(v_raw)
    h_index = prepare(h_raw)
    v_xs = sorted(v_index.keys())
    h_ys = sorted(h_index.keys())
    return v_index, h_index, v_xs, h_ys


# --- containment helper ---
def interval_contains(starts_ends, coord):
    starts, ends = starts_ends
    i = bisect_right(starts, coord) - 1
    if i >= 0 and ends[i] >= coord:
        return True, (starts[i], ends[i])
    return False, None


# --- segment blocked checker (tile-based) ---
def make_segment_blocked(v_index, h_index, v_xs, h_ys, special_points):
    @memo
    def segment_blocked(seg):
        (x1, y1), (x2, y2) = seg

        # normalize endpoints for cache key stability
        if (x1, y1) > (x2, y2):
            (x1, y1), (x2, y2) = (x2, y2), (x1, y1)

        if y1 == y2:
            # horizontal path
            y = y1
            lo, hi = min(x1, x2), max(x1, x2)

            if not v_xs:
                return False

            li = bisect_left(v_xs, lo)
            ri = bisect_right(v_xs, hi)

            for xi in v_xs[li:ri]:
                intervals = v_index[xi]
                contains, interval = interval_contains(intervals, y)
                if not contains:
                    continue

                s, e = interval  # <--- fixed unpack

                if (xi, y) in special_points:
                    if not (s == y and e == y):
                        return True
                    continue

                return True

            return False

        else:
            # vertical path
            x = x1
            lo, hi = min(y1, y2), max(y1, y2)

            if not h_ys:
                return False

            li = bisect_left(h_ys, lo)
            ri = bisect_right(h_ys, hi)

            for yi in h_ys[li:ri]:
                intervals = h_index[yi]
                contains, interval = interval_contains(intervals, x)
                if not contains:
                    continue

                s, e = interval  # <--- fixed unpack

                if (x, yi) in special_points:
                    if not (s == x and e == x):
                        return True
                    continue

                return True

            return False

    return segment_blocked


# --- drop-in optimized solve (uses your parse_lines) ---
def solve_optimized(input_n):
    data = parse_lines(input_n)[0].split(',')

    v_segs = []
    h_segs = []

    diags = [(1, 1), (1, -1), (-1, 1), (-1, -1)]

    heading = 1
    start = (0, 0)
    end = None

    pos = start
    important_points = set()

    # build wall segments (with the same trimming logic)
    for i, ins in enumerate(data):
        d, n = ins[0], int(ins[1:])
        heading = (heading + (-1 if d == 'R' else 1)) % 4
        dest = v_segs if heading & 1 else h_segs
        next_end = vadd(pos, vmul(DIRS[heading], (n, n)))

        if i == 0:
            pos = vadd(pos, DIRS[heading])
        elif i == len(data) - 1:
            end = next_end
            next_end = vsub(next_end, DIRS[heading])

        a, b = pos, next_end
        if a > b:
            a, b = b, a
        dest.append((a, b))
        pos = next_end
        important_points.update(vadd(p, o) for p in (pos, next_end) for o in diags)

    important_points.add(start)
    important_points.add(end)

    # sort walls by length (may help memory/cache locality; optional)
    wall_length = lambda seg: vmagm(vsub(*seg))
    v_segs.sort(key=wall_length, reverse=True)
    h_segs.sort(key=wall_length, reverse=True)

    # build spatial indices and segment_blocked
    v_index, h_index, v_xs, h_ys = build_index(v_segs, h_segs)
    special_points = {start, end}
    segment_blocked = make_segment_blocked(v_index, h_index, v_xs, h_ys, special_points)

    # normalize segment for caching keys
    def norm_seg(a, b):
        return (a, b) if a <= b else (b, a)

    # neighbors: consider L-shaped moves via midpoints
    def get_neighbors(n_pos):
        neighbors = []
        # iterate candidate important points (prune trivial)
        for point in important_points:
            if point == n_pos:
                continue

            # two possible L midpoints
            mid1 = (n_pos[0], point[1])
            mid2 = (point[0], n_pos[1])

            for midpoint in (mid1, mid2):
                seg1 = norm_seg(n_pos, midpoint)
                seg2 = norm_seg(midpoint, point)

                # if either subsegment crosses a wall tile (respecting start/end openness), reject
                if segment_blocked(seg1) or segment_blocked(seg2):
                    continue

                # both clear -> valid neighbor
                neighbors.append((point, vmagm(vsub(point, n_pos))))
                break

        return neighbors

    result_path = wbfs(start, end, get_neighbors)
    if result_path is None:
        return None

    total = sum(vmagm(vsub(result_path[i + 1], result_path[i])) for i in range(len(result_path) - 1))
    return total


setquest(15)

print('part1:', solve_optimized(1))
print('part2:', solve_optimized(2))
print('part3:', solve_optimized(3))
