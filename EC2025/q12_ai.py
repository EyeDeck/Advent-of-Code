# AI generated by ChatGPT using GPT-5.1, using my original q12.py script as a basis

from ec import *
import sys
from collections import deque

sys.setrecursionlimit(10000)


def build_reachsets_bitboard(grid):
    """
    Faster version: every reachset is a Python int bitmask.
    """
    # 1) Assign fixed bit positions
    cells = list(grid.keys())
    idx = {c: i for i, c in enumerate(cells)}
    N = len(cells)

    # 2) Edges: u -> v if v <= u
    edges = {u: [] for u in cells}
    for u, v in grid.items():
        for d in DIRS:
            n = vadd(u, d)
            if n in grid and grid[n] <= v:
                edges[u].append(n)

    # 3) Tarjan SCC
    scc_id, scc_nodes = tarjan_scc(cells, edges)
    nscc = len(scc_nodes)

    # 4) SCC DAG
    scc_edges = [set() for _ in range(nscc)]
    indeg = [0] * nscc
    for u in cells:
        uid = scc_id[u]
        for v in edges[u]:
            vid = scc_id[v]
            if uid != vid and vid not in scc_edges[uid]:
                scc_edges[uid].add(vid)
                indeg[vid] += 1

    # 5) topo order
    from collections import deque
    q = deque([i for i in range(nscc) if indeg[i] == 0])
    topo = []
    while q:
        u = q.popleft()
        topo.append(u)
        for w in scc_edges[u]:
            indeg[w] -= 1
            if indeg[w] == 0:
                q.append(w)

    # 6) DP reach bitboards
    scc_reach = [0] * nscc
    for u in reversed(topo):
        bits = 0
        # bits for nodes inside SCC
        for node in scc_nodes[u]:
            bits |= 1 << idx[node]
        # union children
        for w in scc_edges[u]:
            bits |= scc_reach[w]
        scc_reach[u] = bits

    # 7) per-node reach
    reach = {}
    for node in cells:
        reach[node] = scc_reach[scc_id[node]]

    return reach, idx, cells


# -------------------------
# Tarjan SCC implementation
# -------------------------
def tarjan_scc(nodes, edges):
    """
    Tarjan's algorithm.
    nodes: iterable of nodes (hashable)
    edges: dict node -> iterable(neighbor nodes)
    Returns: (scc_id_of_node: dict, scc_nodes: list of sets)
    """
    index = {}
    lowlink = {}
    stack = []
    onstack = set()
    sccs = []
    idx = 0

    def strongconnect(v):
        nonlocal idx
        index[v] = idx
        lowlink[v] = idx
        idx += 1
        stack.append(v)
        onstack.add(v)

        for w in edges.get(v, ()):
            if w not in index:
                strongconnect(w)
                lowlink[v] = min(lowlink[v], lowlink[w])
            elif w in onstack:
                lowlink[v] = min(lowlink[v], index[w])

        if lowlink[v] == index[v]:
            scc = set()
            while True:
                w = stack.pop()
                onstack.remove(w)
                scc.add(w)
                if w == v:
                    break
            sccs.append(scc)

    for v in nodes:
        if v not in index:
            strongconnect(v)

    scc_id = {}
    for i, s in enumerate(sccs):
        for v in s:
            scc_id[v] = i

    return scc_id, sccs


# -------------------------
# Build reachsets via SCC DAG DP
# -------------------------
def build_reachsets(grid):
    """
    Given grid: dict pos -> value
    Returns:
      reachsets: dict pos -> set(of positions reachable from pos, including itself)
    """
    # 1) Build directed edges: u -> v if grid[v] <= grid[u]
    edges = {c: [] for c in grid}
    for c, v in grid.items():
        for d in DIRS:
            n = vadd(c, d)
            if n in grid and grid[n] <= v:
                edges[c].append(n)

    # 2) Tarjan SCCs
    scc_id, scc_nodes = tarjan_scc(grid.keys(), edges)
    nscc = len(scc_nodes)

    # 3) Build SCC DAG edges (uid -> vid) skipping intra-scc
    scc_edges = [set() for _ in range(nscc)]
    indeg = [0] * nscc
    for u in grid:
        uid = scc_id[u]
        for v in edges[u]:
            vid = scc_id[v]
            if uid != vid and vid not in scc_edges[uid]:
                scc_edges[uid].add(vid)
                indeg[vid] += 1

    # 4) Topological order of SCC DAG (Kahn): parents before children
    q = deque([i for i in range(nscc) if indeg[i] == 0])
    topo = []
    while q:
        u = q.popleft()
        topo.append(u)
        for w in scc_edges[u]:
            indeg[w] -= 1
            if indeg[w] == 0:
                q.append(w)

    # if topo does not contain all nodes, something's wrong (shouldn't happen)
    if len(topo) != nscc:
        raise RuntimeError("SCC DAG topological sort failed (cycle detected in SCC DAG)")

    # 5) DP: compute reach per SCC in reversed topo order (children before parents)
    scc_reach = [set() for _ in range(nscc)]
    for u in reversed(topo):  # children first
        s = set(scc_nodes[u])  # nodes inside this SCC
        # union all child SCC reaches
        for w in scc_edges[u]:
            s |= scc_reach[w]
        scc_reach[u] = s

    # 6) map back to per-node reachset
    reachsets = {}
    for node in grid:
        reachsets[node] = set(scc_reach[scc_id[node]])

    return reachsets


def p1():
    grid, inverse, unique = parse_grid(1)
    reach, idx, cells = build_reachsets_bitboard(grid)
    return reach[(0, 0)].bit_count()


def p2():
    grid, inverse, unique = parse_grid(2)
    reach, idx, cells = build_reachsets_bitboard(grid)
    bounds = grid_bounds(grid)
    br = bounds[2:]
    return (reach[(0, 0)] | reach[br]).bit_count()


def p3():
    grid, inverse, unique = parse_grid(3)
    reach, idx, cells = build_reachsets_bitboard(grid)

    # bitmask of all cells
    all_mask = (1 << len(cells)) - 1
    remaining = all_mask
    acc = 0

    for _ in range(3):
        best_cell = None
        best_ct = -1

        for c in cells:
            m = reach[c] & remaining
            ct = m.bit_count()
            if ct > best_ct:
                best_ct = ct
                best_cell = c

        acc += best_ct
        remaining &= ~reach[best_cell]

    return acc


if __name__ == "__main__":
    setquest(12)

    print("part1:", p1())
    print("part2:", p2())
    print("part3:", p3())
